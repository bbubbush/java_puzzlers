# 7번째 퍼즐 - 변수 교환

```{.java}
public class CleverSwap {
	public static void main(String args[]) {
		int x = 1984;	//	(0x7c0)
		int y = 2001;	//	(0x7d1)
		x ^= y ^= x ^= y;
	}
}
```
이번 퍼즐은 x = 0, y = 1984가 출력된다. 먼저 출력결과부터 이야기하는 이유는 출력결과를 알고 봐도 크게 문제가 없기 떄문이다.

베타적 논리합 연산자와 복합 할당 연산자가 함께 사용되어 x^y의 값을 x에게, y^x의 값을 다시 y에게, x^y의 값을 마지막으로 x에게 담으면서 끝이난다.

이 설명만 들어도 분노가 치밀어 오르기 때문에 결과를 먼저 보는 것이 어쩌면 정신에 도움이 될 수도 있다. 

왜 이런 문제가 등장했는가...누가 XOR 연산자를 저런식으로 두서없이 쓰는가 했는데, 사실 여기에는 코딩의 역사적 단편이 담겨져 있었다.

과거에는 메모리가 제한적이여서 최대한 변수를 줄여야 했다. 
그래서 두 변수의 값을 교환할 때, temp 변수를 하나 만들어 옮기는 방식을 지양하고 (x^y^x) == y의 공식을 활용해 추가적인 변수 없이 두 변수를 교환하는 방법을 썼었다.

실제로 궁금하면 직접 아래 코드를 입력해서 결과를 출력해보면 놀라움을 금치 못하게 될 것이다.

```{.java}
int x = 10;
int y = 20;
x = x^y;
y = y^x;
x = y^x;
```
다만, 현재는 이 방법을 절대로 사용하지 않기를 바란다. 과거에 비해 현재는 충분한 메모리를 확보했으며, 이 코드는 한 눈에 들어오지도 않을 뿐더러 느리다.

또한 컴파일러에 따라 제대로 작동하지 않는 경우도 있어서 메모리가 부족한 과거로 돌아가도 피해야하는 코딩방법이다. 
자바는 피연산자를 왼쪽에서 오른쪽으로 계산하기 때문에 x^=expr 형태의 표현식을 계산할 때 x는 expr이 계산되기 전에 추출되고 expr이 계산된 이후에 합쳐진다.
그럼에도 언급하고 넘어가는 것은 왜 이런 문제가 등장했는지에 대해 알기를 바라기 떄문이다.

다시 코드로 돌아가면 위 코드는 아래처럼 동작하게 된다.

```{.java}
int tmp1 = x;		// x 획득
int tmp2 = y;		// y 획득
int tmp3 = x ^ y;	// x ^ y 계산
x = tmp3;		// x ^ y를 x에 넣음
y = tmp2 ^ tmp3;	// 원래 x를 y에 저장
x = tmp1 ^ y;		// x에 0을 저장
```

따라서 우리가 의도한대로 x에 값이 들어가지 않고, 0이 되어버린다.

물론 괄호와 XOR 연산자를 잘 활용하면 한줄로 두 변수의 값을 교환할 수 있지만 매우 더럽고 알아보기 힘들다. 따라서 지양해야하는 코딩방법이 되겠다.

이 퀴즈의 핵심은 **하나의 표현식에 동일한 변수를 여러 번 할당하지 않아야 한다는 점**이다. 

가장 좋은 코드는 누가 봐도 명확하게 설계자의 의도를 이해할 수 있는 코드란 걸 이 퀴즈를 통해 명심해야 한다.

[[ 소스코드 ]](https://github.com/bbubbush/java_puzzlers/blob/master/Part1_%ED%91%9C%ED%98%84%EC%8B%9D%ED%8D%BC%EC%A6%90/java/CleverSwap.java)