# 6번째 퍼즐 - 다중 자료형 변환

```{.java}
public class Multicast {
	public static void main(String args[]) {
		System.out.println((int)(char)(byte) -1);
	}
}
```

위 코드는 다중 자료형 변환을 하지 말자는 취지로 나온 퀴즈이다. 딱 봐도 답이 무엇인지 예측하기 어렵다. 코드의 직관성이 떨어진다면 좋은 코드라고 절대 말할 수 없다.

byte에서 char로, 다시 int로 간다면 다시 -1이 출력되지 않을까 싶지만, 결과는 65535가 출력된다.

왜 이렇게 출력될까? 앞선 퍼즐과 마찬가지로 부호확장과 관련되어있다. 자바의 사칙연산은 2의 보수를 사용해 수행한다. 

때문에 int 타입의 -1은 32비트가 모두 1로 채워진다.(int: 1111 1111 1111 1111 1111 1111 1111 1111)

처음 int에서 byte로 변환되면 하위 8비트를 제외한 모든 비트는 버리는 캐스팅이 일어난다.(byte: 1111 1111)

그런데 두 번째 변환인 byte에서 char로 변환이 일어날 때 문제가 된다. char는 부호가 없는 자료형이기 때문에 음수를 표현할 수가 없다. 
어려운 용어를 쓰면 '기본 자료형 확장 변환'이 아니라 '기본 자료형 확장 후 축소 변환'이 일어난다. 따라서 byte 자료형이 int 타입으로 확장 변환 된 후, 다시 char 타입으로 축소 변환 된다.

>변환되는 자료형에 관계없이 원래 값이 부호가 있는 타입이라면 부호 확장이 일어나고, char 자료형이라면 '0의 확장'이 일어난다. 

따라서 -1의 byte 타입을 char 타입으로 바꾸면 부호확장이 일어난다.(char: 1111 1111 1111 1111)

때문에 2^16-1의 값이 char의 값이 되고 이를 다시 int로 바꾸게 되면 '0의 확장'일어나 그대로 2^16-1의 값이 출력되는 것이다.

핵심은 **이런 코드 작성을 지양하는 것** 이다. 만약에 이렇게 작성해야 한다면 반드시 주석에 상세한 설명을 담아야 다른 개발자가 혼동하지 않는다.

#### BitMask
char 타입의 변수를 다른 자료형으로 변환할 때는 부호 확장을 원하지 않는다면 비트마스크를 쓰는 것이 좋다.

```{.java}
byte c = 127;
int i = c & 0xffff;
```
위의 코드가 비트마스크의 예시이다. 원하는 비트를 선택하고 싶을 때 사용하는 기술인데 원리는 & 연산자의 특성에 기반한다.

```{.java}
1 & 1 = 1;
1 & 0 = 0;
0 & 1 = 0;
0 & 0 = 0;
```
즉, A & 0 = 0, A & 1 = A임을 활용한다. 1111은 부호가 있다면 15이고, 없다면 -1의 값을 갖게 된다. 
여기에서 첫 번째, 세 번째 비트만 뽑고싶다면 1111 & 1010 의 연산을 수행하면 된다.

혹은 부호확장을 일어나게 하려면 short 타입을 활용하는 것도 좋다.

```{.java}
int i = c;	// 부호확장이 일어나지 않는다.
int j = (short) c;	// 부호확장이 일어난다.
```

short 타입은 byte와 같이 16비트면서 부호가 있는 데이터타입이기 때문이다. 하지만 그냥 작성하면 다른 개발자가 의문을 갖을 수 있으니 주석을 꼭 달아야한다.


[[ 소스코드 ]](https://github.com/bbubbush/java_puzzlers/blob/master/Part1_%ED%91%9C%ED%98%84%EC%8B%9D%ED%8D%BC%EC%A6%90/java/Multicast.java)