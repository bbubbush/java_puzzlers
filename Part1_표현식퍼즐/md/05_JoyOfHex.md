# 5번째 퍼즐 - 16진수의 즐거움

```{.java}
public class JoyOfHex {
	public static void main(String args[]) {
		System.out.println(Long.toHexString(0x100000000L + 0xcafebabe));
	}
}
```
간단하게 16진수인 두 수를 더해서 String value로 출력하는 프로그램이다.단위가 햇갈 수 있으니 보기쉽게 적어보겠다.

0x100000000L

0xcafebabe

위의 값이 long 타입인걸 감안해도 자리수가 다르기 때문에 1cafebabe의 값이 예상되지만 실제로는 cafebabe이 출력된다.

long과 int 값이 더해지면 long 타입으로 출력되어야 하는데 왜 int값끼리 더한 것 마냥 33번 비트를 버리게 된 걸까?

우선 이 문제에는 두 가지 문제가 있다. 첫 번째는 10진수와 16진수의 차이, 두 번째는 서로 다른 자료형의 연산이다. 

10진수는 음수를 표현할 때 단항 부정 연산자(-)를 사용한다. 간단히 말하면 뺄셈기호가 숫자 앞에 있으면 음수, 아니면 양수이다.

반면 16진수나 8진수는 단항 부정 연산자가 없어도 음수인 경우가 있다. 바로 '상위 비트가 정의될 때' 이다. 

여기서 사용한 0xcafebabe는 10진수로 변환하면 3405691582인데 int타입의 최대값인 2147483647을 넘어 오버플로우가 발생해 음수의 값이 된다. 

오버플로우가 일어나 더이상 의도한 값이 되지 않아 0xcafebabe의 값은 쓸모없어 졌다. 

다음으로는 서로 다른 자료형의 연산이다. long과 int의 연산은 자바에서 int타입의 기본 자료형 확장 변환이 일어난다. 이 과정에서 부호 확장도 일어나게 된다.

따라서 0xcafebabe값이 0xffffffffcafebabeL로 확장연산이 일어나게 된다. 

최종적으로 0x100000000L + 0xffffffffcafebabeL 연산이 일어난다. 따라서 이 둘을 더하게 되면 cafebabe 상위 비트는 자릿수가 올라가 아무 의미없는 값이 되고 cafebabe값만 남게 된다.

이 문제를 해결하기 위해선 16진수의 값도 L을 붙여 long 타입이라는 것을 명시적으로 선언해주는 것이다. 이 과정을 통해 부호확장으로 값이 변하는 것을 막을 수 있다.

이 문제의 핵심은 **다양한 진법의 숫자를 함께 연산하지 않는 것**이다. 항상 하나의 진법의 형태로 연산해야 이렇게 눈에 보이지 않는 문제를 피할 수 있다.

[[ 소스코드 ]](https://github.com/bbubbush/java_puzzlers/blob/master/Part1_%ED%91%9C%ED%98%84%EC%8B%9D%ED%8D%BC%EC%A6%90/java/JoyOfHex.java)



