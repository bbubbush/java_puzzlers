# 2번째 퍼즐 - 변화를 위한 시간

```{.java}
public class Change {
	public static void main(String args[]) {
		System.out.println(2.00 - 1.10);
	}
}
```

위의 코드는 톰이 마트에서 $1.10 인 과자를사고 $2.00 를 건내는 것을 구현했다. 당연히 톰은 $0.90, 다시 말해 90cents를 돌려받을 것을 생각했다.

그러나 손에 건내받은 돈은 $0.8999999999999999 였다. 왜 톰은 90cents를 받지 못하게 되었을까?


이러한 문제를 간단하게 "(이진) 부동소수점 연산의 오류"라고 한다. 자바 뿐만 아니라 이진 부동소수점 연산을 사용하는 많은 개발언어에서도 같은 결과가 나온다.

이렇게 부른다는것은 알겠는데 왜 이럴까 궁금할 것이다. 요약하자면 "모든 소수가 float 혹은 double로 표현되는 것이 아니다" 이다.

이진 부동소수점 연산은 소수값을 근사값으로 나타낸다. 그래서 때때로 근사값에 의한 오차가 도드라지는 경우가 나타나는 것이다. 

그래서 소수연산이 중요한 개발을 할 때는 float과 double형의 사용을 **절대로 하면 안 된다.** (사족으로 십진 부동소수점방법도 있다. 이는 매우 정확하지만 연산속도가 상대적으로 느리다.)

해결방안으로는 크게 두 가지 방법이 있다.

>1) 정수부의 여유가 있는 경우에는 자릿수를 올려서 사용한다. 
>예를 들자면 $2.0 에서 $1.1 를 뺀 나머지를 표현해야하는 경우에 단위를 dolor가 아닌 cent에 맞추는 방법이다. 그러면 200 - 110 을 해서 90을 출력할 수 있다.

>2) 십진 부동소수점 연산을 하는 BigDecimal Class를 사용한다.
>다만 주의해야할 점은 BigDecimal의 생성자는 반드시 double형이 아닌 String형으로 해야한다는 것이다. double로 할 경우 매개변수 값 그대로 인스턴스가 된다. 이진 부동소수점의 문제를 막기위해 십진 부동소수점을 사용하는데 이렇게 되면 미세한 오차를 가지고 있는 소수값을 그대로 `사용하게 된다.

하지만 십진 부동소수점 연산은 속도가 느리므로 소수계산이 자주 사용되는 환경에서는 처음부터 십진 부동소수점을 지원하는 언어를 사용하는 것이 좋다.(금융권에서 아직도 코볼이 존재하는 이유를 설명하는해주는 부분이다)

마지막으로 정리하자면 **"자바로 소수연산을 하게된다면 int, long, BigDecimal 같은 안정적인 자료형을 사용해야 한다"** 이다.

[소스코드](https://github.com/bbubbush/java_puzzlers/blob/master/Part1_%ED%91%9C%ED%98%84%EC%8B%9D%ED%8D%BC%EC%A6%90/java/Change.java)



