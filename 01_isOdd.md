# 1번째 퍼즐 - 홀수확인

```{.java}
public static boolean isOdd(int i){
		return i % 2 == 1;
}
```

위의 코드는 매개변수 i가 홀수인지 짝수인지 확인하는 메서드이다. 전혀 문제가 없는 코드같고, 심지어 알고리즘 문제를 풀 때 자주 사용한 방법이라고 생각했다.

하. 지. 만. 정확히 25%의 확률로 잘못된 결과를 출력하는 문제가 많은 코드다. 바로 i가 음수이면서 동시에 홀수일 경우에 이슈가 발생한다.

i가 양수인 경우, i가 음수이지만 짝수인 경우에는 잘 동작한다. 하지만 i = -3이라면 나머지는 -1 이므로 false를 리턴하지만 실은 홀수가 맞다. 

이런 실수는 나머지연산의 특성에 기인한다. 
>(a / b) * b + (a % b) == a (단, b는 0 이외의 int형 자료)
이 식은 간단히 나눗셈에 몫과 나머지를 풀어서 적은 것이다. 여기에는 중요한 특징이 있는데 나머지 연산의 결과는 0이 아닌 값을 리턴할 때는 항상 왼쪽 피연산자의 부호와 같다는 것이다.

예를 들면 3 % 2 = 1, 3 % -2 = 1, -3 % 2 = -1, -3 % -2 = -1 의 나머지연산 결과를 얻을 수 있다. 결과의 부호는 모두 왼쪽 피연산자의 부호와 동일하게 등장한다.

따라서 위의 isOdd 메서드는 매개변수 i가 항상 양수라는 암묵적 가정으로 인해 잘못된 결과를 리턴할 수 있게 된다. 

이를 해결하기 위해서는 포커스를 짝수에 맞추면 된다. 짝수는 음수, 양수에 관계없이 동일하게 옳은 연산을 하기 때문에 i % 2 != 0을 통해 홀수인지 확인하면 된다.

또 다른 방법으로는 비트연산자를 통해 (i & 1) != 0 방법으로 푼다. 이 방법은 10진수를 2진수로 나타낼 때 마지막 숫자가 1이면 홀수, 0이면 짝수인 점을 응용하여 &연산자와 비트마스크인 1을 통해 홀수, 짝수를 판가름 한다. 당연히 앞선 방법보다 더 빠른 수행속도를 제공한다.

**정리하면 나머지 연산자는 항상 피연산자의 부호와 결과가 어떻게 나올지 고민해야 하며 음수의 값일 경우에도 올바르게 동작하는지 확인해야 한다.**